MortScript V3.1

(c) Mirko Schenk
mort@sto-helit.de
http://www.sto-helit.de


With MortScript, you can start, close, activate, and hide programs, and even remote
control them to a certain degree.
It's more an hacker tool without a nifty interface, which can execute some kind of
batch files... For beginners, this might be a bit too complicated.
MortScript is freeware, i.e., you don't need to pay for it. However, modifications
are not allowed. I'd be glad about a small (or big ;)) donation as "thank you!"
and/or "carry on!".
Donations can be done with Paypal (www.paypal.com). Recipient is mort@sto-helit.de.

Features
--------
* Run, activate, hide, and close programs
* Wait functions: certain timespan, wait for existence or activation of windows.
* Send keystrokes: carriage return, space, tabulator, ESCape, direction keys,
                   delete (<-), "Print", and strings
* Send mouse clicks
* File operations: copy, rename/move, delete, create shortcuts
* Create and remove directories
* Read from and write into the registry (string and dword values)
* If conditions, Choice selections and While or Repeat loops
* Some system features (e.g. rotation, volume, backlight brightness, soft reset)

Installation
------------
Copy the "MortScript.exe" contained in the ZIP file anywhere on your PocketPC
(e.g. to "\Program files") and run it, which will create the required registry
entries.
If you use a setup program (from PC or CAB file), this is done by the setup.

Usage
-----
MortScript executes files with the extentions ".mscr" and ".mortrun". The latter
for backward compatibility, the program formerly was named "MortRunner".
Such a file can be created with any text editor. You can even use PocketWord, but
you have to use "Save as - Text" and rename the extention from .txt in .mscr or
.mortrun afterwards.
The lines in this file will be executed sequentially - just like a batch file.
You can create a link to the file you created in the start menu or autostart
folder. You can do this in the "File Explorer" by "copying" the file, and "pasting
a shortcut" in "\Windows\Start Menu" or "\Windows\StartUp".

Autorun
-------
With Autorun.exe, the autostart feature of Windows Mobile can be used more easily.
If a storage card is inserted or removed, Windows executes the program
"autorun.exe" in the folder "2577" (CE code for ARM processors).
If you copy Autorun.exe, MortScript.exe as well as autorun.mscr and/or
autoexit.mscr to this folder, the scripts autorun.mscr (after inserting)
and autoexit.mscr (after removing) will be executed (if the corresponding
script exists).
For backward compatibility, you can also use autorun.mortrun and autoexit.mortrun.
If both .mscr and .mortrun do exist, the .mscr is used.
This feature isn't supported on all devices. For example, I've read that HP
deactivated this feature on iPAQ 2210.

If you rename autorun.exe, it will execute the fitting script. I.e., if
autorun.exe is renamed e.g. to myscript.exe, it will execute myscript.mscr.
Exe and script must be located in the same directory.
If no fitting .mscr is found, the fitting .mortrun is executed if it exists.
This feature is handy for programs which can run other programs but not
do not allow to select .mscr files, e.g. PhonePlus.
In spite to the autorun.exe behavior, the MortScript.exe registered for
.mscr files is used (like if you run the corresponding .mscr file itself),
so it's not necessary to copy it again.
This is done otherwise for autorun.exe to enable the "plug and play" even if
MortScript isn't (already) installed.

Syntax
------
Syntax style

The style is loosely based on (E)BNF.
...:   Fixed value, like the command itself
<...>: Variable value, usually a constant or variable
[...]: Optional, can be omitted
{...}: Can be repeated or omitted
(...): Grouping (usually to make "|"-options better visible)
?...?: Description
x|y|z: Either x, y, or z must be given (usually fixed values).

Generally, there's the follwing syntax:
command =|?space?|?tabulator? {?space?|?tabulator?} [ <parameter> {, parameter } ]

Quotes

Each parameter can be enclosed in quotes. If they aren't, surrounding spaces will
be removed.
Addionally, if a parameter (e.g. a file name) includes a comma, it must be in
quotes to avoid the text after the comma is interpreted as the next parameter.
Quotes are not necessary if the paramter includes spaces in the middle (in spite
to surrounding spaces), but it helps to improve readability.
To get quotes in quotes, you have to double them. For example:
Message "He said: ""This is a test"""

Spaces, tabulators, and new lines

Spaces and tabs are possible at the following locations:
* At the beginning of the line (indentations)
* After the command (but not before '=', if you're using it!)
* Between parameters. They'll be stripped before the first and after the last other
  character if they're not included in quotes!

Line breaks in a command line are possible if you put a "\" at the end of the line
that should be continued. You can do this inside of strings, too. But all spaces,
tabulators, and the line break will be replaced with a single space.
Example:
Message "This is \
	a test"
will show "This is a test".

Case sensitivity

Commands and file names are not case sensitive, but window titles are. But you
can use only parts of the window title. I.e. "Show WORD" will not work, but
"Show Word" will activate "Pocket Word" (or the first window with "Word" in the
title...)

Directories and files

Directories and files must be given with absolute paths (i.e. "\path\to\file.ext"
or "\some\directory"), since Windows Mobile has no "current directory".

Remarks

You can insert remarks by starting the line with the character # (like Perl, Shell
scripts, ...).
Empty lines are allowed, too.

Examples:

SendKeys=" Bla " - the spaces will be send, too.
SendKeys= Bla - here, they won't.
SendKeys "My window", " Bla " - here, a space is used to separate command and
 parameters. The text " Bla " (incl. the spaces) will be send to the window with
 the title "My window".
SendKeys = "A test", "Bla" - ATTENTION, TRAP! Here, the first space is used as
 separator, thus, the "=" belongs to the parameters. Because of this, a window
 with the title "= "A test"" (incl. the quotes surrounding "A test") is searched,
 probably not found, and nothing is sent.
# Some remark


Variables
---------
Variables are marked by percent signs, like %myVariable%. Variable names are not
case sensitive, i.e. %MYVARIABLE% and %myvariable% represent the same value.

Variables can be used for every parameter, but they must stand alone there, i.e.,
no expressions are allowed. This means, "Message %mytext%" will work fine, but
"Message "Test:" %mytext%" won't.

For commands that set variables (like "Set"), be aware the variable name must be
written without the surrounding "%"s. Otherwise, this parameter would be interpreted
as variable value itself, for example:
Set varname, "Test"
Set %varname%, "Something"
would set "Something" to the variable %Test% (value of %varname%)!

An exeption from this rule is the possibility to set variables with
%<variable>% = <expression>
In this case, the percent signs are required to distinguish between variable
assignment and command lines in the old syntax (like "Run=dummy.exe").

Expressions
-----------
If you want to use expressions for parameters, you have to put them in braces.
Exeptions are "Set" and "If expression".
Example:
Message { "Variable contains """ & %Variable% & """" }, %Title%

There are two reasons for this.

The first is backward compatibility. You didn't need to enclose strings in quotes
in former versions and you still don't need to. But if I'd allowed expressions for
every parameter value, how could I know what's a string and what's an expression?
If I just had interpreted everything as expression, it would hail error messages
for old scripts.

The second is performance. Expressions are relatively complex to evaluate, there
are recursions, type conversions, syntax checks, etc. If I'd do that for every
single parameter, you'd notice a difference, esp. on slower devices or if some
CPU eater (like a naviagation system) is running.

Finally, let's get to the possible expressions. 
First of all, you MUST set strings in quotes here to separate them from the
operators.
Variables must be enclosed in percent signs. Numbers can be written without
any marker. However, MortScript currently doesn't support floating point
operations, so decimal dots are not allowed!

Being at numbers, some words to variable types and values.
ALL values are basically treated as strings by MortScript.
If there's any numerical operator, they are converted to integer numbers.
If it's contents doesn't represent a valid number (like "123"), 0 (zero)
is used.
For boolean operators (AND, OR, NOT, and the evaluation of "If expression"),
if the string represents a valid number except 0, it's "true", otherwise
it's "false".

Possible operators by priority (highest first):
()        Brackets
NOT       Negation (True<->False)
* / MOD   Multiplication, division, modulo (remainder)
+ -       Addition, subtraction
& \       String concatenation.
>,  >=, <,  <=, =,  <>   Numerical comparsions
gt, ge, lt, le, eq, ne   Alphanumerical comparsions
AND       Logical and
OR        Logical or

Numerical and alphanumerical comparsions have same priority, they're only
splitted for better overview in the list above.
As there is no typing, there need to be different operators for numerical
and alphanumerical comparsion. This means "123" < "20" will return false
(because 20 is less than 123), but "123" lt "20" will return true (because
in alphabetical order, "1" is less than "2" like "a" is less than "b").
If you can't memorize the alphanumerical operators: They're simply
abbreviations for "greater than", "greater/equal", "less than", etc.

"\" is for paths concatenation. There will be exactly one "\" where the
strings are concatenated. I.e.
"\My documents\" \ "\file.txt"
"\My documents" \ "file.txt"
"\My documents\" \ "file.txt"
will return "\My documents\file.txt".


Control structures
------------------

* If <condition>
     { <commands> }
  [ Else
     { <commands> } ]
  EndIf

  Executes the lines between If and Else or EndIf if the condition is true,
  and those between Else and EndIf if the condition is false.
  If, Else, and EndIf must be in separate lines.
  See "Conditions" below for possible condition expressions.

* (Choice <title>,<hint>,<value>,<value>{,<value>})
  | (ChoiceDefault <title>,<hint>,<default>,<timeout>,<value>,<value>{,<value>})
  Case <value>{,<value>}
     { <commands> }
  [ Case <value>{,<value>}
     { <commands> }  ]
  EndChoice

  Shows a selection with the given values. At "Case", you have to use the index
  (starting with 1). Cancel or no selection will return 0.
  The values can occur in multiple case blocks (e.g. "Case 1,2" and "Case 2,3"),
  a "slide through" or "break" like in C isn't possible as such.

  ChoiceDefault is a variation which enables to set a default selection and
  a timeout after which the selected entry is used.
  If the user selects another entry, the timeout will be restarted.
  The <default> value must be given as index (i.e. "2" for the 2nd entry).
  0 is allowed for no default (i.e. "Cancel" if the user doesn't select an
  entry).
  The <timeout> is given in seconds. With 0, no timeout will be used.

  Example:
  Choice "Test","Choose a value","One","Two","Three"
  Case 1
     Message "One"
  Case 2,3
     Message "Two or three"
  Case 3
     Message "Three"
  Case 0
     Message "Cancel"
     Exit
  EndChoice

* Switch <value>
  [ Case <value>{,<value>}
     { <commands> } ]
  EndSwitch

  Just like Choice, but with a fixed value (usually a variable or expression)
  instead of a selection dialog.
  As with Choice, only numerical comparisons are possible.

* While <condition>
     { <commands> }
  EndWhile

  Executes the lines between While and EndWhile until the condition
  becomes false.
  While and EndWhile must be in separate lines.
  See "Conditions" below for possible condition expressions.

* ForEach <variable>{,<variable>} In <type> <parameter>{,<parameter>}
     { <commands> }
  EndForEach

  This is quite a mighty tool. The given variable(s) is/are set to the values defined by
  the type and parameters in each iteration. This varies from simple value lists (type
  "values") to keys and values of sections in INI files ("iniKeys").
  For all parameters you can use variables and expressions, just like with almost every
  other commands.

  Currently, there are the following variations:

  - ForEach <variable> in values <value> {, <value>}

    Assings each of the given values to the variable in each iteration.

  - ForEach <variable> in split <string>, <separator>, <trim?>

    Similar to the Split command (see below), but the variable will get each part in
    every iteration.

  - ForEach <variable> in charsOf <string>

    Assigns each character of the string to the variable.

  - ForEach <variable> in iniSections <filename>

    Assigns the section names of the given INI file to the variable.

  - ForEach <key>, <value> in iniKeys <filename>, <section>

    Assigns the entries of the given section in the INI file to the variables given
    for "key" and "value". (Key is the part before "=", value is what follows).

  - ForEach <variable> in files <expression>
    ForEach <variable> in directories <expression>

    Assings the found files resp. directories to the variable.
    The expression must consist of a path and a filename expression with jokers, e.g.
    "\Program Files\Mort*" or "\Program Files\Test\*.exe" (similar to XCopy or Move).

* Repeat <count>
     { <commands> }
  EndRepeat

  Repeats the commands between those two commands <count> times.
  Count must be at least 1.

* Sub <subroutine>
     { <commands> }
  EndSub

  Call <subroutine>

  With "Call", the script continues at the line after the "Sub" command
  with the same parameter. When the end of the subroutine (EndSub) is
  reached, it returns to the line after "Call".
  There are no parameters or return values, all variables are global.
  The subroutines must follow the main program, MortScript exits on
  the first "Sub" it encounters.

* Exit

  Stops executing the script.


Conditions
----------

There are these conditions:

* expression <expression>
  ( <expression> )
  { <expression> }

  Checks the given expression. Read the chapters "Variables" and "Expressions"
  for more information.
  The paranthesises allow a syntax similar to C/Java, the braces allow
  unified optics with expressions in parameters.

* equals <value1>,<value2>

  Returns true if the two values are equal. Usually only makes sense, if
  at least one of the parameters is a variable.
  Basically, it's the same as "expression <value1> eq <value2>", but it's
  faster (no expression parsing) and faster to type.

* fileExists <file>

  Checks whether the given file exists. If the parameter identifies
  a directory, the condition will be false!

* dirExists <directory>

  Checks whether the given directory exists. If the parameter identifies
  a file, the condition will be false!

* procExists <application>

  Checks whether the given application is running. The parameter must be
  the name of the exe without path (e.g. solitare.exe).

* wndExists <window title>

  Checks whether a window exists, which includes with the given string
  in it's title. E.g. "If wndExists Word" will be true if a window
  named "PocketWord" exists.

* wndActive <window title>

  Much like "wndExists", but it's only true if the given window is the
  active (foreground) window.

* question <text>[,<title>]

  Will show a simple Yes/No dialog with the given text (Yes/No will be
  localized by Windows). The condition's true if "Yes" was chosen.

* screen landscape|portrait|vga|qvga

  Checks whether the display is in the given mode.
  Be aware "screen vga" will be true if a VGA display is used, no
  matter if "double resolution" (WM2003 SE default) or "real VGA"
  (SE_VGA, OzVGA, ...) is used.

* regKeyExists <root>,<path>,<key>

  Is true if the given registry key exists. Parameters are like those
  of RegDelete.

* regKeyEqualsDWord <root>,<path>,<key>,<value>
  regKeyEqualsString <root>,<path>,<key>,<value>

  Is true if the given registry key contains the given value.

Each condition can be negated with the prefix "not".
E.g. "If not screen landscape" will be the same as "If screen portrait",
and "If not fileExists \Windows\some.dll" will be true if the given file
doesn't exist.

Commands
--------
The follwing commands are currently possible:

Error handling

* ErrorLevel off|critical|syntax|error|warn

  Decides which error messages will be shown. The default is "error".
  It also might change the program flow: If the errorlevel is "warn"
  or "error", the program will be terminated if an error event (see
  list below) occurs. If the level's "off" to "syntax", the error
  will be ignored, so you can check it e.g. with "if wndExists"
  (more details on "If" later on).
  
  Possible errorlevels:
  off      - No error messages at all. The script might be aborted without notice.
  critical - critical error messages
             none currently, reserved for future use
  syntax   - Syntax errors
             e.g. wrong parameter count or invalid conditions
  error    - Other errors
             Non-existing windows, registry entry could not be created/removed,
             new document couldn't be created, directory couldn't be created.
  warn     - Warnings
             File/directory couldn't be removed, copy/move/rename didn't work
             (target already existing?)

Variables

* Set <variable>,<expression>

  Sets the variables value to the result of the expression.
  See "Expressions" above for more details.

  ATTENTION: The expression mustn't be enclosed in braces!

* %<variable>% = <expression>

  Does the same as Set.
  In this case, the percent signs are required to distinguish between variable
  assignment and command lines in the old syntax (like "Run=dummy.exe").

  ATTENTION: The expression mustn't be enclosed in braces!

* Input <variable>, <numbers only?>, <description> [, <title>]

  Shows a dialog with an input field. The value entered will be assinged to the
  variable (or an empty string if "Cancel" is pressed).
  If "numbers only?" is 1, only numbers can be entered.

* Split <string>, <separator>, <trim?>, <variable> {, <variable>}

  Splits the string on each occurence of the separator (single character), and
  assigns the parts the the given variables.
  If there are more variables than parts, the remaining variables will be empty,
  if there are more parts than variables, they'll be ignored.
  If "trim?" is 1, any spaces surrounding the parts will be removed.

  Examples:
  Split "a | b | c","|",1,a,b,c,d
  -> a="a", b="b", c="c", d=""

  Split "a\ b \c.def","\",0,a,b
  -> a="a", b=" b "

* GetRGB <red>,<green>,<blue>,<variable>

  Converts the decimal values of red, green, and blue parts (0-255 each)
  into the the same format as used by GetColorAt.
  Useful in combination with GetColorAt and if (not) equals.

Open applications or documents

* Run <application> [, <parameter>]

  Runs the application.
  Links (*.lnk), parameters, and documents are possible, too.
  The complete path must be specified.

  Examples:
  run \Windows\solitare.exe
  run "\Windows\StartMenu\Inbox.lnk"
  run "\Windows\PWord.exe","\My documents\doc.psw"

* RunWait <application> [, <parameter>]

  Like Run, but waits for the program to exit.
  .lnk files won't work here.

  Please note this will not have the desired effect if the program was running
  already. This is due to Windows' "reactivation" behaviour: The program is
  executed a second time. This second instance looks for an already existing
  instance, and, if found, will activate it and exit itself. Thus, the script
  will continue after the second instance has finished, but the old instance
  is still running.

* New <menu entry>

  Creates a new document (resp. appointment, ...).
  The menu entry must be exactly as it's written in the "new" menu.
  Be aware this depends on your localization!

  Only available in Windows Mobile version.

  Example:
  New Appointment

Window control

* Show <window title>

  Activates the window with the given title.
  Hint: The "Today" screen is titled "Desktop".

* Minimize <window title>

  Hides (minimizes) the window with the given title.

* Close <window title>

  Closes the window with the given title. If it's the main window of
  the application, the appliciation usually is closed, too.

Sending keys

* Send<special character> [<window title>[,<ctrl>,<shift>]]

  Activates the given window and sends the given special character. If no window
  title is given, the currently active window is used.
  <Ctrl> and <shift> are switches for the corresponding keys. If the parameter is
  "1", the key is pressed with the special character.

  These special charaters are possible:
  CR    = carriage return
  Tab   = tabulator
  Esc   = escape (cancel)
  Space = space
  Up/Down/Left/Right = direction pad into the given direction
  Home  = usually moves to the beginning of the line or document
  End   = usually moves to the end of the line or document

  Examples:
  SendCR "ERROR"
  SendDown
  SendHome ,0,1  (mark to beginning of line)

* Snapshot [<window title>]

  Activates the specified window (if one is given) and copies the screen to
  clipboard ("print screen" method of the system, might not work in every
  application).

* SendKeys [<window title>,]<string>

  Sends the given string to the given resp. active (if none is given) window.

  Examples:
  SendKeys "My window","Hi, how are you?"
  SendKeys Some text

* SendCtrlKey [<window title>,]<key>

  Sends Ctrl+<key> to the current or given window.
  E.g. "SendCtrlKey v" sends Ctrl+V (paste) to the current window.
  The key parameter is not case sensitive, i.e. "v" and "V" will do the same.
  It has to be exactly one charater.

Sending taps ("mouse events")

* MouseClick [<window title>,]<x>,<y>

  Simulates a mouse click at the given position.
  If a window is given, the coordinates are relative to its upper left corner.
  If it has a border (e.g. message boxes or questions), it is included.
  If no window is given, the upper left corner of the display is 0,0.

* MouseDblClick [<window title>,]<x>,<y>

  Just like MouseClick, but sending a double click.

* MouseDown [<window title>,]<x>,<y>
  MouseUp [<window title>,]<x>,<y>

  Simulates pressing resp. releasing the mouse button. The parameters are as
  those of MouseClick.
  These two commands should be used together. With those, you can simulate
  "Tap&Hold" (Sleep between them) or "Drag&Drop" (MouseUp on another position).

Waiting

* Sleep <milliseconds>

  Waits the specified time.

* SleepMessage <seconds>, <message> [, <title> [, <allow OK> ] ]

  Shows a wait message with a countdown.
  If "allow OK" is 1, the dialog can be dismissed with a
  button, if not, this is not possible.

* WaitFor <window title>,<seconds>

  Waits (max. the given time) until the told window exists.

* WaitForActive <window title>,<Sekunden>

  Waits (max. the given time) until the told window is active.

Time

* GetTime <variable>

  Sets the variable's value to the current unix timestamp (seconds
  since 01/01/1970).

* GetTime <variable>,<variable>,<variable>

  Retrieves the current time into three variables for hour, minute,
  and seconds.

* GetTime <variable>,<variable>,<variable>,<variable>,<variable>,<variable>

  Like above, but three more variables for day (of month), month,
  and year (4 digits).

* GetTime <variable>,<format>

  Sets a formatted date/time string to the variable.
  These characters will be replaced with the given value:
  H   hour (0-24)
  h   hour (1-12)
  a   am/pm
  A   AM/PM
  i   minute (01-59)
  s   seconds (01-59)
  d   day of month (01-31)
  m   month (01-12)
  Y   year (4 digits)
  y   year (2 digits)
  w   day of week (1=sunday-7=saturday)

  All other characters will remain.

  Examples:
  GetTime time, "h:i:s a"
  GetTime date, m/d/Y

File and Internet operations

* SetProxy <proxy>

  Set the proxy for http access. Currently for Windows Mobile it's not
  possible to use the proxy set in the connections.

  Example:
  SetProxy proxy.foo.bar:8080

* Copy <source file>,<target file>[,<overwrite?>]

  Copies a file.
  The target must contain a filename, too. (I.e., not only the path!)
  If "overwrite?" is 0 or omitted, already existing files won't be overwritten.

  Example:
  Copy "\My documents\test.txt", "\Storage\text.txt"

* XCopy <source files>,<target directory>[,<overwrite?>]

  Copies files to the target directory.
  The source can contain wildcards (* and ?) in the filename (e.g.
  "\My documents\*.psw", but not "\My *\*.psw").
  The target must be an existing directory.
  If "overwrite?" is 0 or omitted, already existing files won't be overwritten.

  Example:
  XCopy "\My documents\*.txt", "\Storage"

* Download <URL>, <target>

  Similar to Copy, but uses an URL (http://... or ftp://...) as source and
  shows a progress window, because this usually takes a bit longer...

  Example:
  Download "http://www.sto-helit.de/test.txt", "\Storage\text.txt"

* Rename <source file>,<target file>[,<overwrite?>]

  Renames or moves a file.
  You have to include the path in the target, too!
  If "overwrite?" is 0 or omitted, already existing files won't be overwritten.

* Move <source files>,<target directory>[,<overwrite?>]

  Moves files to the target directory.
  The source can contain wildcards (* and ?) in the filename (e.g.
  "\My documents\*.psw", but not> "\My *\*.psw").
  The target must be an existing directory.
  If "overwrite?" is 0 or omitted, already existing files won't be overwritten.

* Delete <files>

  Deletes the file(s).
  The file parameter can contain wildcards (* and ?) in the filename (e.g.
  "\My documents\*.psw", but not "\My *\*.psw").

* DelTree <files>

  Deletes the file(s), including all subdirectories.
  If the (sub)directory is empty afterwards, it will be removed.
  The file parameter can contain wildcards (* and ?) in the filename (e.g.
  "\My documents\*.psw", but not "\My *\*.psw"), which will also be used for
  the subdirectories.
  Please handle with care!

* CreateShortcut <link file>,<target file>

  Creates a shortcut (link) to the target file.

  Example:
  CreateShortcut "\Windows\Start menu\Test.lnk","\Storage\Test.exe"

* GetVersion <filename>, <variable>
  GetVersion <filename>, <variable>, <variable>, <variable>, <variable>

  Gets the version number in the resources, either as string ("a.b.c.d") or
  into single variables.
  This information isn't contained or accurate in all files. If contained,
  the version is always in four levels, usually major, minor, patch, and
  build version.

* IniRead <filename>, <section>, <key>, <variable>

  Reads a value for an INI file to the variable (empty string if it doesn't
  exist).
  The filename can be an URL, too. In this case, the file's downloaded from
  the internet.

* ReadFile <filename>, <variable>

  Reads the entire contents of the file into the variable. The file size is
  limited to 128kB or the available memory (whichever is less).
  You can parse the file e.g. with ForEach line in split %contents%,"^LF^",1
  See also the ForEach possibilities for INI files and ReadINI!
  The filename can be an URL, too. In this case, the file's downloaded from
  the internet.

* WriteFile <filename>, <contents>

  Writes the contents to the file. If the file exists, it'll be overwritten.

Directories

* MkDir <directory>

  Creates the directory.
  It's not possible to create multiple levels at once!
  I.e., MkDir "\My documents\Some\Path" will fail if the "Some" subdirectory
  does not already exist.

* RmDir <directory>

  Removes the directory.
  There mustn't be any files or subdirectories contained in the folder.

Registry

* RegReadString <root>,<path>,<key>,<variable>
  RegReadDWord  <root>,<path>,<key>,<variable>

  Reads a value from the registry. If the key doesn't exist, the variable
  will be set to "" (empty string) or 0 (zero).

* RegWriteString <root>,<path>,<key>,<value>
  RegWriteDWord <root>,<path>,<key>,<value>

  Writes a value into the registry. RegWriteString uses a string for "value",
  RegWriteDWord needs a number (invalid values will result in writing the value 0).

  There are the following possibilities for "root":
  HKCU (HKEY_CURRENT_USER)
  HKLM (HKEY_LOCAL_MACHINE)
  HKCR (HKEY_CLASSES_ROOT) or
  HKUS (HKEY_USERS) (only the 4-letter abbreviations!).

  The "key" can be empty for the key.

  Examples:
  RegWriteDWord HKCU,Software\Microsoft\Inbox\Settings,SMSDeliveryNotify,1
      (SMS delivery notification as default, for PE devices)
  RegWriteString HKCU,Software\Mort\MortPlayer\Skins,Skin,Night
  RegWriteString HKCR,pswfile\DefaultIcon,,"officeres.dll,-13072"

* RegDelete <root>,<path>,<key>

  Removes the registry value.
  Values for "root" are as in RegWriteString or -DWord.

* RegDeleteKey <root>, <path>, <delete values?>, <delete subkeys (recursive)?>

  Deletes the registry key.
  "Delete values?" is also used for subkeys if "delete subkeys?" is 1. I.e.,
  RegDeleteKey HKCU,"\Software\Dings",0,1 would remove only empty subkeys (because
  subkeys with entries can't be deleted).

  If the key can't be removed, a message is shown if the ErrorLevel's on "warn" or
  lower.

  The path mustn't be empty to avoid accidental removing of an entiry registry
  section (e.g. if there's a typo in a variable). Still, this command has to be
  handled with care, esp. when using varialbes or expressions for the path!

Dialogs

* Message <text> [,<title>]

  Shows the text in a message window.

* Input <variable>,<numeric?>,<message>[,<title>]

  See "Variables"

* SleepMessage <seconds>, <message> [, <title> [, <allow OK> ] ]

  See "Wait"

System

* GetSystemPath <path>, <variable>

  Receives the localized directory name for certain locations. Possible
  values for "path" are:
  * ProgramsMenu - "Programs" in Start menu
  * StartMenu    - Start menu
  * Startup      - Startup (links are run after soft reset)
  * Documents    - "\My documents", WM version: requires WM2003 or higher
  * ProgramFiles - "\Program files", WM version: requires WM2003 or higher
  * ScriptExe    - Path to MortScript.exe (not including filename)
  * ScriptPath   - Path to current script (not including filename)
  * ScriptName   - Name of current script (not including path and extension)
  * ScriptExt    - Extension of current script (".mscr" or ".mortrun").

  I.e., you could run the current script with
  Run {%ScriptExe% \ "MortScript.exe"}, {%ScriptPath% \ %ScriptName% & %ScriptExt%}
  (given you name the variables like the path parameter).

* GetColorAt <x>, <y>, <variable>

  Gets the color of the point. At least on some devices, the title bar is
  ignored, i.e. it receives the color of the underlying today background.
  See also GetRGB in Variables.

* GetWindowText <x>, <y>, <variable>

  Receives the window text of the element that's located at the given
  point. In most dialogs you can get labels, button labels, or contents
  of edit boxes that way. It doesn't work as intended for application
  drawn elements (like in most games) or e.g. list boxes. In this cases,
  it'll usually return nothing (empty string) or the application's title.

* Rotate 0|90|180|270

  Rotates the screen.
  0=default, 90=right handed, 180=upside down, 270=left handed

  Only available in Windows Mobile version, where it requires at least WM2003SE

* SetVolume <value>

  Sets the system volume to the given value. Valid values are from
  0 (silent) to 255 (full power).
  Some devices, like Loox720, will round to certain steps, but most
  devices will allow all 256 steps.

  Only available in Windows Mobile version.

* SetBacklight <battery>,<external>

  Sets the brightness of the backlight to the given values.
  "Battery" is for battery power, "external" for external power.
  Valid values are between 0 (off) and 100.
  This command will not work on all devices!
  Also, the value for the highest luminance differs for each
  device. Currently, I know about devices with 10, 60, or 100
  as highest possible value.

  Only available in Windows Mobile version.

* Kill <application>

  Terminates the application. The parameter must be the name of the exe
  without path (e.g. solitare.exe).

  ATTENTION: This command kills the process regardless of any losses!
  It might lead to data loss, hangups, or error messages.
  Wherever it's possible, you should prefer Close, which gives the program
  the chance to a proper ending.

* IdleTimerReset

  Resets the idle timer of the system. This way, you can avoid (if called
  in a loop) or postpone the automatical power off.

  Only available in Windows Mobile version.

* Reset

  Executes a soft reset

  Only available in Windows Mobile version.



History
-------

V3.1
* Renamed to MortScript, new extension .mscr
* Multiline statements (with "\")
* Expressions as parameters (with "{ expression }")
* Simplified "If expression" with parentheses or braces
* ^CR^, ^LF^, and ^TAB^ for quoted strings
* ForEach loops
* Switch conditions
* Read and write text files (IniRead, ReadFile, WriteFile)
* Download files from internet (Download, IniRead, ReadFile)
* Overwrite parameter for XCopy, Copy, Move, and Rename
* Other new commands: RegDeleteKey, Input, SleepMessage, GetVersion,
  GetSystemPath, GetColorAt, GetRGB, GetWindowText

V3.0
* Subroutines
* Variables
* Expressions
* Some new comparsion possibilities
* Retrieve values from the Registry or the current time
* Checking for and killing running applications
* Avoid/postpone auto power off (IdleTimerReset)

V2.61
* Bugfix: Error message for Delete was shown on successfull deletion
* Choice selection: First entry is preselected, bigger buttons

V2.6
* New tool: Autorun.exe
* Choice selection
* New condition "regKeyExists"
* Optional title for Message and If question
* New commands: MouseDblClick, CreateShortcut, Rotate, SetBacklight, SetVolume, Reset, Exit

V2.5
* Improved error handling (error messages, abort on errors, ErrorLevel command)
* Enabled If conditions and While loops
* Added "Message", "MkDir", and "RmDir" commands
* "Run" supports parameters
* Fixed the problem with menus (If MouseClick opened a menu, the script wasn't
  continued until the menu was closed manually)

V2.3
* Added "New" command

V2.2
* XCopy, Move, and wildcards for Delete
* Added RegDelete
* Copy doesn't overwrite no more (use Delete before if necessary!)

V2.1
* Repeat loops
* Hint when started without parameters

V2.0
* Mouse clicks
* File operations
* Write in registry
* More Send commands (SendKeys, direction pad, Home/End)
* Improved parser (optionally space instead of "=", parameters in quotes)

V1.22
* added Close

V1.21
* added SendSpace

V1.2
* added SendTab, SendEsc, Snapshot
* Modified icon for .mortrun files

V1.1
* added WaitFor/WaitForActive

V1.02
* added SendCR
* Bugfix at registration of ".mortrun"

V1.0
* First version

Donations
---------
Well, of course the program is Freeware, so you don't need to pay anything.
But if you think "Wow, what a great program, I'd love to give some of my money to
show how much I love it!", just go ahead.
Go to www.paypal.com, register or login, and send the money to mort@sto-helit.de.
